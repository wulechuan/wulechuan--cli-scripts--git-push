/**
 * @typedef {import('chalk').ChalkInstance} 范_粉笔工具
 */

/**
 * @typedef {import('node:path')} 范_路径工具
 */

/**
 * @typedef {import('fs-extra')} 范_文件系统工具之扩展版
 */

/**
 * @typedef {import('../辅助工具集')} 范_本工具集随附之辅助工具集
 */

/**
 * @typedef {import('../../../package.json')} 范_本工具集自身的_packageJSON
 */





/**
 * @param {object}                        配置项集
 *
 * @param {范_粉笔工具}                   配置项集.粉笔工具
 * @param {范_路径工具}                   配置项集.路径工具
 * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
 *
 * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
 *
 * @param {string}                        配置项集.本工具集一切命令行消息之前缀
 * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
 * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
 *
 * @param {string}                        配置项集.视作须为其安装本工具集的_npm_项目的根文件的完整路径
 * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
 * @param {string}                        配置项集.本工具集随附应用范本集文件夹之相对路径
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
 *
 * @returns {Promise<any>}
 */
module.exports = function 通过从应用范本集中复制文件的做法来自动发布命令行脚本集 ({
    粉笔工具,
    路径工具,
    文件系统工具之扩展版,

    本工具集随附之辅助工具集,

    本工具集一切命令行消息之前缀,
    本工具集自身根文件夹之完整路径,
    本工具集自身的_packageJSON,

    视作须为其安装本工具集的_npm_项目的根文件的完整路径,
    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
    本工具集随附应用范本集文件夹之相对路径,
    发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
    发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
} = {}) {
    if (typeof 视作须为其安装本工具集的_npm_项目的根文件的完整路径 !== 'string' || !视作须为其安装本工具集的_npm_项目的根文件的完整路径.trim()) {
        return Promise.reject(new Error(`${
            本工具集一切命令行消息之前缀
        }\n    ${
            粉笔工具.red(`没有给出【${
                粉笔工具.yellow('视作须为其安装本工具集的_npm_项目的根文件的完整路径')
            }】。`)
        }\n`))
    }

    return Promise.all([
        // 暂无需要导入的模块。
    ]).then(([
        // 暂无导入的模块。
    ]) => {
        return 发布命令行脚本之范本集_主体功能({
            粉笔工具,
            路径工具,
            文件系统工具之扩展版,

            本工具集随附之辅助工具集,

            本工具集一切命令行消息之前缀,
            本工具集自身根文件夹之完整路径,
            本工具集自身的_packageJSON,

            视作须为其安装本工具集的_npm_项目的根文件的完整路径,
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            本工具集随附应用范本集文件夹之相对路径,
            发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
            发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
            发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
        })
    })
}





/**
 * @typedef {object} 范_命令行脚本文件之发布任务配置
 *
 * @property {string} 原始范本文件的二次相对路径
 * @property {string} 拟将范本文件发布于其中的文件夹的相对路径
 */





/**
 * @param {object}                        配置项集
 *
 * @param {范_粉笔工具}                   配置项集.粉笔工具
 * @param {范_路径工具}                   配置项集.路径工具
 * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
 *
 * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
 *
 * @param {string}                        配置项集.本工具集一切命令行消息之前缀
 * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
 * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
 *
 * @param {string}                        配置项集.视作须为其安装本工具集的_npm_项目的根文件的完整路径
 * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
 * @param {string}                        配置项集.本工具集随附应用范本集文件夹之相对路径 - 默认值为 '源代码/应用范本集' 。
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
 * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
 *
 * @returns {Promise<any>}
 */
function 发布命令行脚本之范本集_主体功能 ({
    粉笔工具,
    路径工具,
    文件系统工具之扩展版,

    本工具集随附之辅助工具集,

    本工具集一切命令行消息之前缀,
    本工具集自身根文件夹之完整路径,
    本工具集自身的_packageJSON,

    视作须为其安装本工具集的_npm_项目的根文件的完整路径,
    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
    本工具集随附应用范本集文件夹之相对路径,
    发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
    发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
    发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
}) {
    if (typeof 本工具集随附应用范本集文件夹之相对路径 !== 'string' || !本工具集随附应用范本集文件夹之相对路径.trim()) {
        本工具集随附应用范本集文件夹之相对路径 = '源代码/应用范本集'
    }

    if (typeof 用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径 !== 'string' || !用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径.trim()) {
        用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径 = 视作须为其安装本工具集的_npm_项目的根文件的完整路径
    }

    console.log(`\n\n\n\n\n${
        本工具集一切命令行消息之前缀
    } ${
        粉笔工具.bgGreenBright.black(' 现在开始发布各命令行脚本 ')
    }\n`)

    console.log(`\n${
        本工具集一切命令行消息之前缀
    }\n\n    视作须为其安装本工具集的_npm_项目的根文件的完整路径：\n    "${
        粉笔工具.green(视作须为其安装本工具集的_npm_项目的根文件的完整路径)
    }"\n\n    用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径：\n    "${
        粉笔工具.green(用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径)
    }"\n`)

    console.log(
        '    个别脚本文件应发布在目标项目之根文件夹下：\n   ',
        发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下,
        '\n'
    )



    /** @type {Array<范_命令行脚本文件之发布任务配置>} */
    const 所有命令行脚本文件之发布任务配置集 = [
        发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
            ? {
                原始范本文件的二次相对路径: 'PowerShell/.Push-将代码依次推送至多个集得源.ps1',
                拟将范本文件发布于其中的文件夹的相对路径: '.',
            }
            : {
                原始范本文件的二次相对路径: 'PowerShell/Push-将代码依次推送至多个集得源.ps1',
                拟将范本文件发布于其中的文件夹的相对路径: '用于研发阶段的命令行工具/PowerShell',
            }
        ,

        发布本工具集随附的命令行脚本时_个别脚本文件应发布在目标项目之根文件夹下
            ? {
                原始范本文件的二次相对路径: 'bash/push-将代码依次推送至多个集得源.sh',
                拟将范本文件发布于其中的文件夹的相对路径: '.',
            }
            : {
                原始范本文件的二次相对路径: 'bash/push-将代码依次推送至多个集得源.sh',
                拟将范本文件发布于其中的文件夹的相对路径: '用于研发阶段的命令行工具/bash',
            }
        ,

        {
            原始范本文件的二次相对路径: 'PowerShell/Add-添加所有集得源.ps1',
            拟将范本文件发布于其中的文件夹的相对路径: '用于研发阶段的命令行工具/PowerShell',
        },

        {
            原始范本文件的二次相对路径: 'bash/Add-添加所有集得源.sh',
            拟将范本文件发布于其中的文件夹的相对路径: '用于研发阶段的命令行工具/bash',
        },
    ].filter(任务 => !!任务)



    return Promise.allSettled(所有命令行脚本文件之发布任务配置集.map(某命令行脚本文件之发布任务配置 => {
        const {
            原始范本文件的二次相对路径,
            拟将范本文件发布于其中的文件夹的相对路径,
        } = 某命令行脚本文件之发布任务配置

        发布某脚本文件({
            粉笔工具,
            路径工具,
            文件系统工具之扩展版,

            本工具集随附之辅助工具集,

            本工具集一切命令行消息之前缀,
            本工具集自身根文件夹之完整路径,
            本工具集自身的_packageJSON,

            本工具集随附应用范本集文件夹之相对路径,
            原始范本文件的二次相对路径,
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            拟将范本文件发布于其中的文件夹的相对路径,
            发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
            发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
        })

        return Promise.resolve()
    }))





    /**
     * @param {object}                        配置项集
     *
     * @param {范_粉笔工具}                   配置项集.粉笔工具
     * @param {范_路径工具}                   配置项集.路径工具
     * @param {范_文件系统工具之扩展版}       配置项集.文件系统工具之扩展版
     *
     * @param {范_本工具集随附之辅助工具集}   配置项集.本工具集随附之辅助工具集
     *
     * @param {string}                        配置项集.本工具集一切命令行消息之前缀
     * @param {string}                        配置项集.本工具集自身根文件夹之完整路径
     * @param {范_本工具集自身的_packageJSON} 配置项集.本工具集自身的_packageJSON
     *
     * @param {string}                        配置项集.本工具集随附应用范本集文件夹之相对路径
     * @param {string}                        配置项集.原始范本文件的二次相对路径
     * @param {string}                        配置项集.用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径
     * @param {boolean}                       配置项集.拟将范本文件发布于其中的文件夹的相对路径
     * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件
     * @param {boolean}                       配置项集.发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份
     */
    function 发布某脚本文件 ({
        粉笔工具,
        路径工具,
        文件系统工具之扩展版,

        本工具集随附之辅助工具集,

        本工具集一切命令行消息之前缀,
        本工具集自身根文件夹之完整路径,
        本工具集自身的_packageJSON,

        本工具集随附应用范本集文件夹之相对路径,
        原始范本文件的二次相对路径,
        用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
        拟将范本文件发布于其中的文件夹的相对路径,
        发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件,
        发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份,
    } = {}) {
        const 拼接路径片段 = 路径工具.join
        const 求完整路径 = 路径工具.resolve
        const 求路径中的文件之文件全名 = 路径工具.basename
        const 求路径末端实体的容纳文件夹之路径 = 路径工具.dirname



        const 命令行脚本文件之文件名 = 求路径中的文件之文件全名(原始范本文件的二次相对路径)
        const 原始范本文件的一次相对路径 = 拼接路径片段(本工具集随附应用范本集文件夹之相对路径, 原始范本文件的二次相对路径)
        const 容纳原始范本文件之文件夹之完整路径 = 求完整路径(求路径末端实体的容纳文件夹之路径(原始范本文件的一次相对路径))

        const 原始范本文件之完整路径 = 求完整路径(拼接路径片段(
            视作须为其安装本工具集的_npm_项目的根文件的完整路径,
            本工具集随附应用范本集文件夹之相对路径,
            原始范本文件的二次相对路径
        ))

        const 容纳发布的文件的文件夹之完整路径 = 求完整路径(拼接路径片段(
            用于容纳发布的各命令行脚本的文件树之根文件夹之完整路径,
            拟将范本文件发布于其中的文件夹的相对路径
        ))

        const 拟发布成为之文件之完整路径 = 拼接路径片段(
            容纳发布的文件的文件夹之完整路径,
            命令行脚本文件之文件名
        )



        let 原始文件确实存在 = false
        if (文件系统工具之扩展版.existsSync(原始范本文件之完整路径)) {
            const vscode_tasksJSON_文件描述符 = 文件系统工具之扩展版.statSync(原始范本文件之完整路径)
            if (vscode_tasksJSON_文件描述符.isFile()) {
                原始文件确实存在 = true
            }
        }

        if (!原始文件确实存在) {
            console.log(`${
                本工具集一切命令行消息之前缀
            }\n${
                粉笔工具.red('欲部署某命令行脚本工具时，未找到原始文件。已略过该部署任务。')
            }\n所涉文件之描述如下：\n    相对路径： "${
                粉笔工具.redBright(原始范本文件的二次相对路径)
            }"\n    完整路径： "${
                粉笔工具.redBright(原始范本文件之完整路径)
            }"\n`)

            return
        }



        console.log(`${
            本工具集一切命令行消息之前缀
        }\n\n    找到原始的命令行脚本范本：\n    "${
            粉笔工具.white(`${容纳原始范本文件之文件夹之完整路径}${路径工具.sep}`)
        }${
            粉笔工具.cyan(命令行脚本文件之文件名)
        }"\n`)

        console.log(`    ${
            粉笔工具.yellow('拟发布为：')
        }：\n    "${
            粉笔工具.green(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
        }${
            粉笔工具.greenBright(命令行脚本文件之文件名)
        }"\n`)



        let 欲发布的文件业已存在 = false
        if (文件系统工具之扩展版.existsSync(拟发布成为之文件之完整路径)) {
            const vscode_tasksJSON_文件描述符 = 文件系统工具之扩展版.statSync(拟发布成为之文件之完整路径)
            if (vscode_tasksJSON_文件描述符.isFile()) {
                欲发布的文件业已存在 = true
            }
        }



        let 应发布该文件 = false
        let 应保存备份文件 = false

        if (欲发布的文件业已存在) {
            console.log(`   ${
                粉笔工具.bgYellow.black(' 欲发布的命令行脚本文件业已存在 ')
            }`)
            // console.log(`    ${
            //     粉笔工具.yellow('欲发布的命令行脚本文件业已存在')
            // }：\n    "${
            //     粉笔工具.blue(`${容纳发布的文件的文件夹之完整路径}${路径工具.sep}`)
            // }${
            //     粉笔工具.blueBright(命令行脚本文件之文件名)
            // }"\n`)

            if (发布本工具集随附的命令行脚本时应覆盖旧有的命令行脚本文件) {
                应发布该文件 = true
                应保存备份文件 = !!发布本工具集随附的命令行脚本时若覆盖旧有的命令行脚本文件则先行备份

                if (应保存备份文件) {
                    console.log(`   ${粉笔工具.bgMagenta.black(' 该文件将被覆盖，但会先行备份 ')}`)
                } else {
                    console.log(`   ${粉笔工具.bgRed.whiteBright(' 该文件将被覆盖，且不会先行备份 ')}`)
                }
            } else {
                应发布该文件 = false
                应保存备份文件 = false

                console.log(`   ${粉笔工具.bgGreen.black(' 不会发布新文件，而是保留旧有文件 ')}\n`)
            }
        } else {
            应发布该文件 = true
            应保存备份文件 = false
        }



        if (!应发布该文件) {
            return
        }



        文件系统工具之扩展版.mkdirpSync(容纳发布的文件的文件夹之完整路径)



        if (应保存备份文件) {
            const 该命令行脚本文件之扩展名 = 路径工具.extname(命令行脚本文件之文件名)
            const 时间戳 = 本工具集随附之辅助工具集.求当前时间之文本_可用于文件系统之文件名()

            const 备份文件之文件名 = `${
                路径工具.basename(命令行脚本文件之文件名, 该命令行脚本文件之扩展名)
            }-吴乐川备份于-${时间戳}${
                该命令行脚本文件之扩展名
            }`

            const 备份文件之完整路径 = 拼接路径片段(
                容纳发布的文件的文件夹之完整路径,
                备份文件之文件名
            )

            文件系统工具之扩展版.copySync(拟发布成为之文件之完整路径, 备份文件之完整路径)
            console.log(`   ${粉笔工具.bgGreen.black(' 旧文件现已备份 ')}`)
        }



        文件系统工具之扩展版.copySync(原始范本文件之完整路径, 拟发布成为之文件之完整路径)
        console.log(`   ${粉笔工具.bgBlueBright.black(' 该文件现已发布 ')}\n\n`)
    }
}
